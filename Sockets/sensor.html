<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Phone IMU → Hub (Match 2P)</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 14px; margin: 0; background:#0b0f14; color:#e6edf3; }
    h2 { margin: 6px 0 10px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    .card { background:#111823; border:1px solid #223; border-radius:12px; padding:12px; flex: 1 1 340px; }
    label { display:block; font-size: 12px; opacity: .8; margin-top: 8px; }
    input { width:100%; font-size:16px; padding:10px; border-radius:10px; border:1px solid #334; background:#0b0f14; color:#e6edf3; }
    button { font-size: 16px; padding: 12px 14px; border-radius: 12px; border: 1px solid #334; background:#1b2a41; color:#e6edf3; }
    button:active { transform: scale(0.98); }
    .btnGood { background:#1e5a3a; }
    .btnDanger { background:#5a1e2a; }
    .btnOnce { background:#3a3a8a; }
    .big { font-size: 20px; padding: 18px 14px; width:100%; }
    .fire { background:#b02020; border-color:#ff5050; }
    .fire.on { background:#ff2d2d; }
    pre { background:#061018; border:1px solid #223; color:#7CFF7C; padding:12px; border-radius:12px; white-space:pre-wrap; line-height:1.35; margin: 10px 0 0; }
    .hint { font-size:12px; opacity:.75; margin-top:6px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <h2>Phone IMU Sender (2P Match)</h2>

  <div class="row">
    <div class="card">
      <div class="row">
        <div style="flex:1">
          <label>Player Name</label>
          <input id="name" placeholder="ex) Minyeol" />
        </div>
        <div style="flex:1">
          <label>UID (auto)</label>
          <input id="uid" class="mono" />
          <div class="hint">UID는 localStorage에 저장됩니다.</div>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnPerm">센서 권한</button>
        <button id="btnConnect" class="btnGood">WS 연결</button>
        <button id="btnDisconnect" class="btnDanger">WS 해제</button>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnJoin" class="btnGood">접속하기(매칭)</button>
        <button id="btnLeave" class="btnDanger">나가기</button>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnStart" class="btnGood">전송 시작</button>
        <button id="btnStop" class="btnDanger">전송 중지</button>
        <button id="btnOnce" class="btnOnce">1회 전송</button>
      </div>

      <div class="hint">
        HTTPS(ngrok) 환경이면 iOS 센서가 더 잘 켜집니다.
      </div>
    </div>

    <div class="card">
      <button id="btnFire" class="big fire">FIRE (Hold)</button>
      <div class="hint">누르고 있는 동안 fire=1 전송</div>
      <div class="hint" id="matchHint"></div>
    </div>
  </div>

  <pre id="out">Loading...</pre>

<script>
(() => {
  const out = document.getElementById("out");
  const matchHint = document.getElementById("matchHint");
  const log = (s)=> out.textContent = s;

  const nameEl = document.getElementById("name");
  const uidEl  = document.getElementById("uid");

  const LS_UID = "imu_uid_v2";
  const LS_NAME = "imu_name_v2";

  function ensureUid() {
    let u = localStorage.getItem(LS_UID);
    if (!u) {
      u = (crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2) + Date.now());
      localStorage.setItem(LS_UID, u);
    }
    return u;
  }

  uidEl.value = ensureUid();
  nameEl.value = localStorage.getItem(LS_NAME) || "";
  nameEl.addEventListener("change", () => localStorage.setItem(LS_NAME, nameEl.value.trim()));

  const wsProto = (location.protocol === "https:") ? "wss" : "ws";
  const WS_URL_BASE = `${wsProto}://${location.host}/ws`;

  let ws = null;
  let sending = false;
  let timer = null;

  let counts = { ori:0, motion:0 };
  let latest = { yaw:null,pitch:null,roll:null, ax:null,ay:null,az:null, gx:null,gy:null,gz:null };
  let sensorsAttached = false;
  let lastSentMs = 0;

  const buttons = { fire: 0 };
  let currentMatchId = "";

  function status(extra="") {
    const rs = ws ? ws.readyState : "null";
    const u = uidEl.value.trim();
    const n = nameEl.value.trim();
    const url = `${WS_URL_BASE}?uid=${encodeURIComponent(u)}&name=${encodeURIComponent(n)}&role=phone`;
    return [
      extra,
      `isSecureContext: ${window.isSecureContext}`,
      `URL: ${location.href}`,
      `WS_URL: ${url}`,
      `WS: ${rs} (0=CONN,1=OPEN,2=CLOSING,3=CLOSED)`,
      `Sending: ${sending}`,
      `Match: ${currentMatchId || "(none)"}`,
      `Events: ori=${counts.ori}, motion=${counts.motion}`,
      `ORI yaw/pitch/roll: ${latest.yaw} / ${latest.pitch} / ${latest.roll}`,
      `ACC ax/ay/az: ${latest.ax} / ${latest.ay} / ${latest.az}`,
      `GYRO gx/gy/gz: ${latest.gx} / ${latest.gy} / ${latest.gz}`,
      `BTN fire=${buttons.fire}`,
      `LastSent(ms): ${lastSentMs}`
    ].filter(Boolean).join("\n");
  }

  async function requestPerm() {
    try {
      if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
        await DeviceMotionEvent.requestPermission();
      }
    } catch {}
    try {
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
        await DeviceOrientationEvent.requestPermission();
      }
    } catch {}
  }

  function attachSensorsOnce() {
    if (sensorsAttached) return;
    sensorsAttached = true;

    window.addEventListener("deviceorientation", (e) => {
      counts.ori++;
      latest.yaw   = (e.alpha === null ? null : Number(e.alpha.toFixed(2)));
      latest.pitch = (e.beta  === null ? null : Number(e.beta.toFixed(2)));
      latest.roll  = (e.gamma === null ? null : Number(e.gamma.toFixed(2)));
    }, { passive:true });

    window.addEventListener("devicemotion", (e) => {
      counts.motion++;
      const a = e.accelerationIncludingGravity || e.acceleration;
      latest.ax = (a?.x == null ? null : Number(a.x.toFixed(3)));
      latest.ay = (a?.y == null ? null : Number(a.y.toFixed(3)));
      latest.az = (a?.z == null ? null : Number(a.z.toFixed(3)));

      const r = e.rotationRate;
      latest.gx = (r?.alpha == null ? null : Number(r.alpha.toFixed(2)));
      latest.gy = (r?.beta  == null ? null : Number(r.beta.toFixed(2)));
      latest.gz = (r?.gamma == null ? null : Number(r.gamma.toFixed(2)));
    }, { passive:true });
  }

  function connectWS() {
    return new Promise((resolve, reject) => {
      const u = uidEl.value.trim();
      const n = nameEl.value.trim();
      const url = `${WS_URL_BASE}?uid=${encodeURIComponent(u)}&name=${encodeURIComponent(n)}&role=phone`;

      ws = new WebSocket(url);

      ws.onopen = () => {
        ws.send(JSON.stringify({ type:"hello", uid:u, name:n, role:"phone", ts:Date.now() }));
        resolve();
      };
      ws.onerror = () => reject(new Error("ws error"));
      ws.onclose = (e) => {
        sending = false;
        if (timer) { clearInterval(timer); timer = null; }
        log(status(`WS CLOSED code=${e.code} reason=${e.reason||"(none)"}`));
      };
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === "match_start") {
            currentMatchId = msg.match_id || "";
            matchHint.textContent = `매치 시작! match_id=${currentMatchId}`;
            log(status("MATCH_START 수신"));
          } else if (msg.type === "match_end") {
            currentMatchId = "";
            matchHint.textContent = `매치 종료`;
            log("MATCH_END\n" + JSON.stringify(msg, null, 2) + "\n\n" + status());
          } else if (msg.type === "queue_status") {
            matchHint.textContent = `대기중... queue_len=${msg.queue_len}`;
            log(status("QUEUE"));
          } else if (msg.type === "match_abort") {
            currentMatchId = "";
            matchHint.textContent = `매치 중단: ${msg.reason}`;
            log(status("MATCH_ABORT"));
          }
        } catch {}
      };
    });
  }

  async function ensureConnected() {
    if (ws && ws.readyState === 1) return true;
    try { await connectWS(); return true; }
    catch { return false; }
  }

  function disconnectWS() {
    sending = false;
    if (timer) { clearInterval(timer); timer = null; }
    if (ws) { try { ws.close(); } catch {} ws = null; }
    currentMatchId = "";
    matchHint.textContent = "";
    log(status("Disconnected"));
  }

  function buildImuMsg(typeOverride="imu") {
    const u = uidEl.value.trim();
    const n = nameEl.value.trim();
    return {
      type: typeOverride,
      ts: Date.now(),
      uid: u, name: n, role: "phone",
      match_id: currentMatchId || "",
      yaw: latest.yaw, pitch: latest.pitch, roll: latest.roll,
      ax: latest.ax, ay: latest.ay, az: latest.az,
      gx: latest.gx, gy: latest.gy, gz: latest.gz,
      oriCount: counts.ori, motionCount: counts.motion,
      fire: buttons.fire
    };
  }

  async function joinMatch() {
    attachSensorsOnce();
    await requestPerm();

    const ok = await ensureConnected();
    if (!ok) { log(status("WS 연결 실패")); return; }

    ws.send(JSON.stringify({
      type: "join_request",
      ts: Date.now(),
      uid: uidEl.value.trim(),
      name: nameEl.value.trim(),
      role: "phone"
    }));

    log(status("join_request 보냄"));
  }

  async function leaveAll() {
    const ok = await ensureConnected();
    if (!ok) { log(status("WS 연결 실패")); return; }
    ws.send(JSON.stringify({ type:"leave", ts:Date.now(), uid:uidEl.value.trim(), role:"phone" }));
    currentMatchId = "";
    matchHint.textContent = "";
    log(status("leave 보냄"));
  }

  async function startSending() {
    attachSensorsOnce();
    await requestPerm();

    const ok = await ensureConnected();
    if (!ok) { log(status("WS 연결 실패")); return; }

    sending = true;
    if (timer) clearInterval(timer);

    timer = setInterval(() => {
      if (!sending || !ws || ws.readyState !== 1) return;
      ws.send(JSON.stringify(buildImuMsg("imu")));
      lastSentMs = Date.now();
      log(status("Sending..."));
    }, 50);

    log(status("Started"));
  }

  function stopSending() {
    sending = false;
    if (timer) { clearInterval(timer); timer = null; }
    log(status("Stopped"));
  }

  async function sendOnce() {
    attachSensorsOnce();
    await requestPerm();

    const ok = await ensureConnected();
    if (!ok) { log(status("WS 연결 실패")); return; }

    ws.send(JSON.stringify(buildImuMsg("imu")));
    lastSentMs = Date.now();
    log(status("Sent once"));
  }

  // FIRE hold
  const btnFire = document.getElementById("btnFire");
  function setFire(on) {
    buttons.fire = on ? 1 : 0;
    btnFire.classList.toggle("on", !!on);
    log(status(on ? "FIRE=1" : "FIRE=0"));
  }
  btnFire.addEventListener("pointerdown", (e) => { e.preventDefault(); setFire(true); });
  btnFire.addEventListener("pointerup",   (e) => { e.preventDefault(); setFire(false); });
  btnFire.addEventListener("pointercancel", (e) => { e.preventDefault(); setFire(false); });
  btnFire.addEventListener("pointerleave", (e) => { if (buttons.fire) setFire(false); });

  // Buttons
  document.getElementById("btnPerm").onclick = async () => { await requestPerm(); log(status("Permission requested")); };
  document.getElementById("btnConnect").onclick = async () => {
    try { await connectWS(); log(status("WS Connected")); }
    catch { log(status("WS 연결 실패")); }
  };
  document.getElementById("btnDisconnect").onclick = disconnectWS;

  document.getElementById("btnJoin").onclick = joinMatch;
  document.getElementById("btnLeave").onclick = leaveAll;

  document.getElementById("btnStart").onclick = startSending;
  document.getElementById("btnStop").onclick = stopSending;
  document.getElementById("btnOnce").onclick = sendOnce;

  log(status("Ready"));
})();
</script>
</body>
</html>
